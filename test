ProcessingData_YearlyReturn = function(data){
  ###数据处理函数，将指数或收益率序列转化为年度收益率
  ###data的第一列为时间
  ###data的之后几列为指数或净值序列
  result = NULL
  ColNames = colnames(data)[-1]
  TheTimeName = colnames(data)[1]
  
  for(i in 1:length(ColNames)) {
    A = ColNames[i]
    temp = data[,c(TheTimeName,A)]
    temp = xts(x = temp[,-1],order.by = temp[,1])
    temp = yearlyReturn(temp)
    temp = as.data.frame(temp)
    colnames(temp) = A
    temp[,TheTimeName] = rownames(temp)
    temp = temp[,c(TheTimeName,A)]
    if(is.null(result)){
      result = temp
    } else {
      result = merge(result,temp,by = TheTimeName)
    }
  }
  result = result[-1,]
  return(result)
}

ProcessingData_MonthlyReturn = function(data){
  ###数据处理函数，将指数或收益率序列转化为年度收益率
  ###data的第一列为时间
  ###data的之后几列为指数或净值序列
  result = NULL
  ColNames = colnames(data)[-1]
  TheTimeName = colnames(data)[1]
  
  for(i in 1:length(ColNames)) {
    A = ColNames[i]
    temp = data[,c(TheTimeName,A)]
    temp = xts(x = temp[,-1],order.by = temp[,1])
    temp = monthlyReturn(temp)
    temp = as.data.frame(temp)
    colnames(temp) = A
    temp[,TheTimeName] = rownames(temp)
    temp = temp[,c(TheTimeName,A)]
    if(is.null(result)){
      result = temp
    } else {
      result = merge(result,temp,by = TheTimeName)
    }
  }
  result = result[-1,]
  return(result)
}

ProcessingData_WeeklyReturn = function(data){
  ###数据处理函数，将指数或收益率序列转化为年度收益率
  ###data的第一列为时间
  ###data的之后几列为指数或净值序列
  result = NULL
  ColNames = colnames(data)[-1]
  TheTimeName = colnames(data)[1]
  
  for(i in 1:length(ColNames)) {
    A = ColNames[i]
    temp = data[,c(TheTimeName,A)]
    temp = xts(x = temp[,-1],order.by = temp[,1])
    temp = weeklyReturn(temp)
    temp = as.data.frame(temp)
    colnames(temp) = A
    temp[,TheTimeName] = rownames(temp)
    temp = temp[,c(TheTimeName,A)]
    if(is.null(result)){
      result = temp
    } else {
      result = merge(result,temp,by = TheTimeName)
    }
  }
  result = result[-1,]
  return(result)
}

ProcessingData_WeeklyVol = function(data){
  ###数据处理函数，将指数或收益率序列转化为年度收益率
  ###data的第一列为时间
  ###data的之后几列为指数或净值序列
  result = NULL
  ColNames = colnames(data)[-1]
  TheTimeName = colnames(data)[1]
  
  for(i in 1:length(ColNames)) {
    A = ColNames[i]
    temp = data[,c(TheTimeName,A)]
    temp = xts(x = temp[,-1],order.by = temp[,1])
    func1 = function(x) {return(sd(x))}
    temp = apply.weekly(temp,func1)
    temp = as.data.frame(temp)
    colnames(temp) = A
    temp[,TheTimeName] = rownames(temp)
    temp = temp[,c(TheTimeName,A)]
    if(is.null(result)){
      result = temp
    } else {
      result = merge(result,temp,by = TheTimeName)
    }
  }
  result = result[-1,]
  return(result)
}

ProcessingData_MonthlyVol = function(data){
  ###数据处理函数，将指数或收益率序列转化为年度收益率
  ###data的第一列为时间
  ###data的之后几列为指数或净值序列
  result = NULL
  ColNames = colnames(data)[-1]
  TheTimeName = colnames(data)[1]
  
  for(i in 1:length(ColNames)) {
    A = ColNames[i]
    temp = data[,c(TheTimeName,A)]
    temp = xts(x = temp[,-1],order.by = temp[,1])
    func1 = function(x) {return(sd(x))}
    temp = apply.monthly(temp,func1)
    temp = as.data.frame(temp)
    colnames(temp) = A
    temp[,TheTimeName] = rownames(temp)
    temp = temp[,c(TheTimeName,A)]
    if(is.null(result)){
      result = temp
    } else {
      result = merge(result,temp,by = TheTimeName)
    }
  }
  result = result[-1,]
  return(result)
}


ProcessingData_MonthlyReturn_1W = function(data){
  ###数据处理函数，将指数或收益率序列转化为年度收益率
  ###data的第一列为时间
  ###data的之后几列为指数或净值序列
  result = NULL
  ColNames = colnames(data)[-1]
  TheTimeName = colnames(data)[1]
  
  for(i in 1:length(ColNames)) {
    A = ColNames[i]
    temp = data[,c(TheTimeName,A)]
    temp = xts(x = temp[,-1],order.by = temp[,1])
    func1 = function(x) {return(x[length(x)])}
    func2 = function(x) {return(x[length(x) - 5])}
    temp1 = apply.monthly(temp,func1)
    temp2 = apply.monthly(temp,func2)
    temp = cbind(temp1,temp2)
    temp = as.data.frame(temp)
    temp[,A] = (temp[,1] - temp[,2])/temp[,2]
    temp[,TheTimeName] = rownames(temp)
    temp = temp[,c(TheTimeName,A)]
    if(is.null(result)){
      result = temp
    } else {
      result = merge(result,temp,by = TheTimeName)
    }
  }
  result = result[-1,]
  return(result)
}


ProcessingData_ToMonthFreq = function(data){
  ###数据处理函数，将指数或收益率序列转化为年度收益率
  ###data的第一列为时间
  ###data的之后几列为指数或净值序列
  result = NULL
  ColNames = colnames(data)[-1]
  TheTimeName = colnames(data)[1]
  
  for(i in 1:length(ColNames)) {
    A = ColNames[i]
    temp = data[,c(TheTimeName,A)]
    temp = xts(x = temp[,-1],order.by = temp[,1])
    temp = apply.monthly(temp,last)
    temp = as.data.frame(temp)
    colnames(temp) = A
    temp[,TheTimeName] = rownames(temp)
    temp = temp[,c(TheTimeName,A)]
    if(is.null(result)){
      result = temp
    } else {
      result = merge(result,temp,by = TheTimeName)
    }
  }
  return(result)
}

ProcessingData_ToWeekFreq = function(data){
  ###数据处理函数，将指数或收益率序列转化为年度收益率
  ###data的第一列为时间
  ###data的之后几列为指数或净值序列
  result = NULL
  ColNames = colnames(data)[-1]
  TheTimeName = colnames(data)[1]
  
  for(i in 1:length(ColNames)) {
    A = ColNames[i]
    temp = data[,c(TheTimeName,A)]
    temp = xts(x = temp[,-1],order.by = temp[,1])
    temp = apply.weekly(temp,last)
    temp = as.data.frame(temp)
    colnames(temp) = A
    temp[,TheTimeName] = rownames(temp)
    temp = temp[,c(TheTimeName,A)]
    if(is.null(result)){
      result = temp
    } else {
      result = merge(result,temp,by = TheTimeName)
    }
  }
  return(result)
}


SignificanceAnalysisForClassification = function(data){
  #对于分类问题进行变量的显著性分析
  #data的第一列为Y1,代表分类变量,第二列为Y2代表连续变量，之后几列为X

  Y1 = colnames(data)[1]
  Y2 = colnames(data)[2]
  ColNames = colnames(data)[3:ncol(data)]
  
  result = data.frame(解释变量 = ColNames)
  for(i in 1:length(ColNames)){
    A = ColNames[i]
    ##计算相关系数
    temp = data[,c(Y2,A)]
    temp = temp[complete.cases(temp),]
    cor1 = cor(x = temp[,1],y = temp[,2])
    cor2 = cor(x = temp[,1],y = temp[,2],method = "spearman")
    result[i,"Pearson相关系数"] = cor1
    result[i,"Spearman相关系数"] = cor2
    
    ##相关系数的显著性检验
    a = cor.test(x = temp[,1],y = temp[,2])
    result[i,"Pearson相关系数检验p值"] =  a$p.value
    b = cor.test(x = temp[,1],y = temp[,2],method = "spearman")
    result[i,"Spearman相关系数检验p值"] =  b$p.value
    
    
    ##方差分析与Logistic回归
    temp = data[,c(Y1,A)]
    temp = temp[complete.cases(temp),]
    TheAov = aov(temp[,2] ~ temp[,1])
    TheAov = summary(TheAov)
    TheAov = TheAov[[1]]
    p = TheAov$`Pr(>F)`[1]
    print(paste("方差分析显著性检验的p值为:",p))
    result[i,"方差分析p值"] = p
    ##查看Logistic回归的结果
    TheLR = glm(Y ~ . ,data = temp,family=binomial(link='logit'))
    TheLR = summary(TheLR)
    TheLR = TheLR$coefficients
    TheLR = as.data.frame(TheLR)
    p = TheLR$`Pr(>|z|)`[2]
    print(paste("Logistic回归显著性检验的p值为:",p))
    result[i,"Logistic回归p值"] = p
  }
  return(result)
}

SelectFactor = function(data = TrainData){
  #该函数的功能是从一系列变量中识别出显著的变量
  #Input:TrainData为训练数据集
  #Output:
  
  AllRiskFactors = colnames(TrainData)[-1] #所有自变量的名称
  result1 = NULL #识别出的变量名称
  result2 = NULL #识别出的变量序号
  for(i in 1:length(AllRiskFactors)) {
    RiskFactor = AllRiskFactors[i]
    TheData = TrainData[,c("Y",RiskFactor)]
    
    ###计算p值
    TheAov = aov(TheData[,2] ~ TheData[,1])
    TheAov = summary(TheAov)
    TheAov = TheAov[[1]]
    p = TheAov$`Pr(>F)`[1]
    print(paste(i,"###",RiskFactor,"###",p))

    ###判断是否通过显著性检验
    if(p <=0.35) {
      index = 1
      result1 = c(result1,RiskFactor)
    } else {
      index = 0
    }
    result2 = c(result2,index)
  }
  if(length(result1) == 0) {
    #temp = c("Wind一致预期CPI","远期利率_国债","美元兑人民币_即期汇率","M2_同比","股债收益差")
    #result1 = c(result1,temp)
    #result1 = unique(result1)
    #result1 = temp
    print(paste("##################变量太少:",length(result1)))
  }
  result = list(result1,result2)
  return(result)
}

#a = SelectFactor(data = TrainData)

SelectFactorByLR = function(data = TrainData){
  #该函数的功能是从一系列变量中识别出显著的变量
  #Input:TrainData为训练数据集
  #Output:
  
  AllRiskFactors = colnames(TrainData)[-1] #所有自变量的名称
  result1 = NULL #识别出的变量名称
  result2 = NULL #识别出的变量序号
  for(i in 1:length(AllRiskFactors)) {
    RiskFactor = AllRiskFactors[i]
    TheData = TrainData[,c("Y",RiskFactor)]
    
    ###计算p值
    TheLR = glm(Y ~ . ,data = TheData,family=binomial(link='logit'))
    TheLR = summary(TheLR)
    TheLR = TheLR$coefficients
    TheLR = as.data.frame(TheLR)
    p = TheLR$`Pr(>|z|)`[2]
    print(paste(i,"###",RiskFactor,"###",p))
    if(is.na(p)) {p = 1}
    ###判断是否通过显著性检验
    if(p <=0.35) {
      index = 1
      result1 = c(result1,RiskFactor)
    } else {
      index = 0
    }
    result2 = c(result2,index)
  }
  if(length(result1) < 2) {
    #temp = c("WindCPI一致预期数据","十年期国债到期收益率_环比变化_滞后一期","PB差_滞后一期","M2_同比增速_滞后二期")
    #result1 = c(result1,temp)
    #result1 = unique(result1)
    #result1 = temp
    print(paste("##################变量太少:",length(result1)))
  }
  result = list(result1,result2)
  return(result)
}

PredictByRF = function(train = TrainData,test = TestData) {
  temp = train$Y
  temp = as.character(temp)
  temp = as.numeric(temp)
  yuzhi = sum(temp)/length(temp)
  rf = randomForest(Y ~ .,data = train,cutoff = c(1-yuzhi,yuzhi))
  pred = predict(rf,test)
  pred = as.character(pred)
  return(pred)
}

PredictByLR = function(train = TrainData,test = TestData) {
  temp = train$Y
  temp = as.character(temp)
  temp = as.numeric(temp)
  yuzhi = sum(temp)/length(temp)
  glm = glm(Y ~ . ,data = train,family=binomial(link='logit'))
  #glm = step(glm)
  pred = predict(glm,test,type = "response")
  pred = ifelse(pred >= yuzhi,1,0)
  return(pred)
}

PredictByLR2 = function(data,test) {
  temp = data$Y
  temp = as.character(temp)
  temp = as.numeric(temp)
  yuzhi = sum(temp)/length(temp)
  #yuzhi = 0.5
  glm = glm(Y ~ . ,data = data,family=binomial(link='logit'))
  #glm = step(glm)
  #result5 = pR2(glm)[4]  #计算方法1 - ln(LM)/ln(L0)
  #result5 = as.numeric(result5)
  #result5 = 1-exp((glm$deviance-glm$null.deviance)/nrow(train))
  pred = predict(glm,newdata = test,type = "response")
  pred = ifelse(pred >= yuzhi,1,0)
  predForTraindata = predict(glm,data,type = "response")
  predForTraindata = ifelse(predForTraindata >= yuzhi,1,0)
  DataForCalAccuracy = data.frame(real = data$Y,pred = predForTraindata)
  result6 = mean(DataForCalAccuracy$real == DataForCalAccuracy$pred)
  result1 = pred  #result1代表预测结果
  result1 = as.numeric(result1)
  glmsum = summary(glm)
  result7 = 1 - glmsum$deviance/glmsum$null.deviance
  result5 = result7
  glmsum = coef(glmsum)
  glmsum = as.data.frame(glmsum)
  result2 = rownames(glmsum)[-1] #result2代表筛选出的变量
  result3 = glmsum[result2,"Estimate"]  #result3代表筛选出的变量的回归系数
  result4 = glmsum[result2,"Pr(>|z|)"] #result4代表筛选出的变量的显著性检验的p值
  result = list(result1,result2,result3,result4,result5,result6,result7)
  return(result)
}


PredictByMLR = function(train = TrainData,test = TestData) {
  
  thepolr = polr(Y ~ . ,data = train)  
  pred = predict(thepolr,test)
  return(pred)
}

PredictByLRL1 = function(train = TrainData,test = TestData) {
  #temp = train$Y
  #temp = as.character(temp)
  #temp = as.numeric(temp)
  #yuzhi = sum(temp)/length(temp)
  train.x = as.matrix(train[,-1]);
  train.y = train[, 1];
  test.x = as.matrix(test);
  model = cv.glmnet(train.x, train.y, family = "binomial")
  pred = predict(model, test.x, type = "class");
  pred = as.character(pred)
  pred = as.numeric(pred)
  return(pred)
}

#PredictByRF(train = TrainData,test = TestData)

###统计统计回测结果
PerformanceAnalyticsFunction1 = function(data = result) {
  #result为分类的真实结果和预测的结果,
  #TheResult$datetime = as.Date(TheResult$datetime)
  
  years = substr(data$datetime,1,4)
  years = unique(years)
  ResultIndex = data.frame(datetime = c(years,"正确率","相对盈亏比"))
  TheNames = colnames(data)[6:ncol(data)]
  for(i in 1:length(TheNames)) {
    TheName = TheNames[i]
    print(TheName)
    Temp = data[,c("datetime","Y",TheName)]
    Temp[,"index"] = ifelse(Temp[,2] == Temp[,3],1,0)
    zhengquelvall = sum(Temp$index)/nrow(Temp)
    Temp$datetime = as.Date(Temp$datetime)
    index = xts(x = Temp[,"index"],order.by = Temp[,1])
    index = apply.yearly(index,sum)
    index = as.data.frame(index)
    index[,1] = index[,1]
    index[,1] = round(index[,1],3)
    colnames(index) = TheName
    ##计算全区间的正确率
    index["正确率",] = zhengquelvall
    ###计算全区间的相对盈亏比
    Temp = data[,c("datetime","Y",TheName,"收益差")]
    Temp[,"index"] = ifelse(Temp[,2] == Temp[,3],1,0)
    Temp$收益差 = abs(Temp$收益差)
    a = mean(Temp[which(Temp$index == 1),"收益差"])
    b = mean(Temp[which(Temp$index == 0),"收益差"])
    index["相对盈亏比",]  = a/b
    ResultIndex = cbind(ResultIndex,index)
  }
  return(ResultIndex)
  print(ResultIndex)
}

###计算净值
PerformanceAnalyticsFunction2 = function(data) {
  ###回测
  #净值
  data[,"基准0"] = 0
  data[,"基准1"] = 1
  
  NetValue = data.frame(datetime = data$datetime)
  idx = which(colnames(data) == "Y")
  TheList = colnames(data)[(idx + 1):ncol(data)]
  TimeRange = data$datetime
  NetValue[,TheList] = NA
  
  for(i in 1:length(TheList)){
    #i = 1
    CLName = TheList[i]
    for(j in 1:length(TimeRange)){
      TheDatetime = TimeRange[j]
      #print(paste(i,"--",CLName,"--",TheDatetime))
      index = data[which(data$datetime == TheDatetime),CLName]
      if(index == 1){
        ratio = data[which(data$datetime == TheDatetime),"沪深300收益率"] + 1
      } 
      if(index == 0){
        ratio = data[which(data$datetime == TheDatetime),"中证500收益率"] + 1
      }
      NetValue[which(NetValue$datetime == TheDatetime),CLName] = ratio
    }
    NetValue[,CLName] = cumprod(NetValue[,CLName])
  }
  return(NetValue)
}

PerformanceAnalyticsFunction3 = function(data){
  ###策略评价
  TheList = colnames(data)[-1]
  EvaluateIndicator = data.frame(模型 = TheList)
  Indexs = c("累计回报","年化回报","夏普比率","单期最大跌幅")
  EvaluateIndicator[,Indexs] = NA
  
  for(i in 1:length(TheList)){
    #i = 1
    CLName = TheList[i]
    
    ##计算累计收益
    EvaluateIndicator[which(EvaluateIndicator$模型 == CLName),"累计回报"] = data[nrow(data),CLName] - 1
    
    data$datetime = as.character(data$datetime)
    data$datetime = as.Date(data$datetime)
    ##计算年化回报
    StartDatetime = data$datetime[1]
    EndDatetime = data$datetime[nrow(data)]
    a = as.numeric(EndDatetime - StartDatetime) + 30
    LastNetValue = data[nrow(data),CLName]
    YearRet = LastNetValue^(365/a) - 1
    EvaluateIndicator[which(EvaluateIndicator$模型 == CLName),"年化回报"] = YearRet
    
    ##计算夏普比率
    price = xts(x = data[,CLName], order.by = data[,1])
    Ret = CalculateReturns(price, method = "discrete")
    TheMaxDrawdown = maxDrawdown(Ret)
    Ret = as.data.frame(Ret)
    Ret = Ret[complete.cases(Ret),]
    TheVol = sqrt(12)*sd(Ret)
    EvaluateIndicator[which(EvaluateIndicator$模型 == CLName),"夏普比率"] = (YearRet - 0.02)/TheVol
    
    ##计算单期最大跌幅
    EvaluateIndicator[which(EvaluateIndicator$模型 == CLName),"单期最大跌幅"] = min(Ret)
    
    ##计算最大回撤
    EvaluateIndicator[which(EvaluateIndicator$模型 == CLName),"最大回撤"] = TheMaxDrawdown
  }
  return(EvaluateIndicator)
  
}

CorAnalysis = function(data,n){
  ###该函数实现的功能是计算两个变量间的滚动相关系数
  ###data有三列，第一列为日期，后两列分别代表两个变量
  ###n代表的是滚动期的长度
  result = data.frame(datetime = data[n:nrow(data),1])
  j = 0
  for(i in n:nrow(data)){
    j = j + 1
    x = data[(i - n + 1):i,2]
    y = data[(i - n + 1):i,3]
    result[j,"相关系数"] = cor(x,y)
  }
  ggplot(data = result,aes(x = datetime, y = 相关系数)) + geom_line(size = 1) + labs(title = paste("                                  ",colnames(data)[2],"与",colnames(data)[3],"的滚动相关系数"))
  return(result)
}



